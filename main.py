import google.generativeai as palm
import os
import openai
import cohere
import random
import re

# Load API keys from environment variables
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")

# Initialize APIs
openai.api_key = OPENAI_API_KEY

def load_system_prompt():
    with open("System Prompt.txt", "r") as file:
        return file.read()

rules = load_system_prompt()
# Functions to interact with OpenAI
# Conversational Speech
def generate_conversation_speech(character, characters, rules, current_context, most_recent):

    #prompt = "It is your turn to speak, what will you say?"
    full_prompt = "\n".join(characters[character]["memory"]) + "\n" + "Current conversational context:" + "\n" + current_context + "Most recent message(s):" + "\n" + "\n".join(most_recent)

    system_prompt = f"You are {character}, a character in an Among-Us style murder mystery game. {rules}. You have been selected to speak next in the conversation, what will you say? (Respond with plaintext, do not include speach marks or {character} says, etc). \n Remember, you are {character} and your output is what they will say next in the conversation, if you do not believe it is {character}'s turn to speak next, simply state you have nothing to say."
    
    response = openai.chat.completions.create(
        model="gpt-4o-mini", 
        messages=[
            {"role": "system", "content": system_prompt},
            {"role": "user", "content": full_prompt}
        ],
        max_tokens=100,
    )

    return response.choices[0].message.content.split(":")[-1]

def generate_responses(characters, rules, conversation_context, most_recent):
    """Generate a response from each AI character based on the conversation context."""
    responses = {}
    for character in characters:
        if characters[character]["alive"]:
            response = generate_conversation_speech(character, characters, rules, conversation_context, most_recent)
            responses[character] = response
    return responses


def summarise_conversation(conversation_history):
    summary_prompt = (
        "Summarize the following conversation in a few sentences. Focus on key details relevant to the murder mystery.\n\n"
        f"Conversation history:\n{conversation_history}"
    )
    response = openai.chat.completions.create(
        model="gpt-4o-mini", 
        messages=[
            {"role": "system", "content": "You are a detective's assistant summarizing a conversation in a murder mystery. Only summarise the speech, do not analyse underlying intentions or provide commentary and ensure not to assert anything as fact, use langauge such as person A claims, person B questions, person C denies, etc. If two or more characters provide conflicting series of event then this should be highlighted."},
            {"role": "user", "content": summary_prompt}
        ],
        max_tokens=150,
    )
    return response.choices[0].message.content


def select_best_response(responses, conversation_context, most_recent):
    response_summary = "\n".join([f"{char}: {resp}" for char, resp in responses.items()])
    
    overseer_prompt = (
        f"The following responses were generated by the characters in a murder mystery conversation. "
        f"Choose the most fitting response based on the current conversation context:\n\n{conversation_context}\n\n"
        f"The most recent messages: \n{most_recent}\n"
        f"Responses:\n{response_summary}\n\n"
        f"Provide the name of the character whose response best fits the conversation."
    )

    response = openai.chat.completions.create(
        model="gpt-4o-mini", 
        messages=[
            {"role": "system", "content": f"You are an overseer managing the flow of conversation in a murder mystery game. Your answer must be a single word. Mike is never an acceptable answer."},
            {"role": "user", "content": overseer_prompt}
        ],
        max_tokens=5,
    )

    speaker = response.choices[0].message.content.strip().rstrip(".").rstrip(",")
    best_response = responses[speaker].replace("{", "").replace("}", "")
    return best_response, speaker


def generate_next_speaker(characters, memory, rules):

    #prompt = "On a scale of 1 to 10, how eager are you to speak next in this conversation? Provide a number between 1 and 10. IMPORTANT: YOUR RESPONSE MUST BE AN INTEGER VALUE"
    full_prompt = "\n".join(memory) #+ "\n" + prompt
    listington = list(char for char in characters if characters[char]["alive"])
    system_prompt = f"You are the GameMaster of a murder mystery game. You will be provided a transcript of a conversation and your job is to assess who should speak next. Your answer must be a single word, one of the following names: {listington} and no other text."
    
    response = openai.chat.completions.create(
        model="gpt-4o-mini", 
        messages=[
            {"role": "system", "content": system_prompt},
            {"role": "user", "content": full_prompt}
        ],
        max_tokens=5,
    )

    print(response.choices[0].message.content.strip())
    
    return response.choices[0].message.content.strip()

def generate_room_selection(character, available_rooms, memory, rules):

    prompt = f"Here are the available rooms: {', '.join(available_rooms)}. Which room would you like to stay in tonight?"
    full_prompt = "\n".join(memory) + "\n" + prompt

    system_prompt = f"You are {character}, a character in a murder mystery game. {rules}"
    
    response = openai.chat.completions.create(
        model="gpt-3.5-turbo", 
        messages=[
            {"role": "system", "content": system_prompt},
            {"role": "user", "content": full_prompt}
        ],
        max_tokens=10,
    )
    
    room_choice = response.choices[0].message.content.strip()
    return room_choice


def generate_voting_prompt(character, memory, rules, conversation_summary):
    """Generate a prompt for the AI to vote on who they think the killer is."""
    prompt = (
        f"Based on the following summary of the conversation so far, please decide who you think the killer is. "
        f"Consider any suspicious behavior or inconsistent alibis, but if you are unsure, make your best guess. "
        f"You cannot vote for yourself.\n\n"
        f"Conversation summary (Hearsay):\n{conversation_summary}\n\n"
        f"Your memory (Matter-of-fact):\n{memory}\n\n"
        f"Who do you think is the killer? Respond only with a character name."
    )

    # Generate the response using the AI
    response = openai.chat.completions.create(
        model="gpt-4o",
        messages=[
            {"role": "system", "content": f"You are {character}, a character in a murder mystery game. {rules}"},
            {"role": "user", "content": prompt}
        ],
        max_tokens=20
    )
    
    vote = response.choices[0].message.content.strip().replace(".","")
    print(f"{character} votes for: {vote}")
    return vote

def ai_vote_for_killer(player_name, characters, conversation_summary, rules):
    """Conduct the voting phase where each alive character votes for who they think the killer is."""
    votes = {}
    votes[player_name] = input("Who are you voting for?")

    for character in characters:
        if characters[character]["alive"]:
            # Prompt the AI to vote for the killer
            vote = generate_voting_prompt(character, characters[character]["memory"], rules, conversation_summary)
            
            # Ensure they don't vote for themselves
            while vote == character or (vote != player_name and vote not in characters):
                vote = random.choice([char for char in characters if char != character and characters[char]["alive"]])

            votes[character] = vote
            print(f"{character} voted for {vote}.")
        
    
    return votes
# Character profiles
characters = {
    "Jerry": {"alive": True, "profile": ["You are Jerry, you are soft-spoken and introverted."], "memory": []},
    "Dave": {"alive": True, "profile": ["You are Dave, you are a friendly guy but a bit of a follower. You prefer to blend into the background."], "memory": []},
    "Owen": {"alive": True, "profile": ["You are Owen, you have a short temper and a bit of an ego."], "memory": []},
    "Hank": {"alive": True, "profile": ["You are Hank, you're always suspicious of everyone around you, including the Detective."], "memory": []},
    "Debra": {"alive": False, "profile": ["You are Debra, you're somewhere between apathetic and non-chalant, nothing really phases you."], "memory": []}
}
# Rooms in the mansion
rooms = ["Attic", "Kitchen", "Library", "Basement", "Cellar"]
crime_scenes = []

# Select a random killer
#killer = random.choice(list(characters.keys()))
#killer = "Jerry"
#print("The killer is: " + killer)
#characters[killer]["memory"].append("IMPORTANT: YOU ARE THE KILLER! Don't let anyone find out.")

# for character in characters:
#     characters[character]["memory"].append("IMPORTANT: You are NOT theM
room_facts = {
    "Attic": "There is a distinct humming noise.",
    "Kitchen": "The oven is broken.",
    "Library": "The smell of old books is overwhelming.",
    "Basement": "There are strange, echoing noises.",
    "Cellar": "There are 4 kegs of beer."
}

#TESTING---------------------
characters["Jerry"]["memory"].append("BEGIN Action Phase 0: \n You (Jerry) spent the night in the Kitchen, you witness Mike killing Debra in the Kitchen - Mike is the Killer. \n END of Action Phase 0")
characters["Dave"]["memory"].append("BEGIN Action Phase 0: \n You (Dave) spent the night in the Library, Owen was there with you and no-one else. In the morning it is revealed that Debra's corpse was found in the Kitchen. \n END of Action Phase 0")
characters["Owen"]["memory"].append("BEGIN Action Phase 0: \n You (Owen) spent the night in the Library, Dave was there with you and no-one else. In the morning it is revealed that Debra's corpse was found in the Kitchen. \n END of Action Phase 0")
characters["Hank"]["memory"].append("BEGIN Action Phase 0: \n You (Hank) spent the night in the Attic, no-one else was there with you. In the morning it is revealed that Debra's corpse was found in the Kitchen. \n END  of Action Phase 0")

#TESTING OVER-----------------

# Shared memory that all characters know
shared_memory = []


# Placeholder for generating summaries at the end of action phase
def generate_summaries(room_assignments, kill_info):
    # TODO: Implement summary logic
    pass

# Action Stage
def action_stage():
    room_assignments = {room: [] for room in rooms}
    
    # Each character chooses a room
    for character in characters:
        if characters[character]["alive"]:
            room = choose_room(character)
            room_assignments[room].append(character)

    # Killer decides if they kill
    kill_info = killer_decision(room_assignments)

    # Generate summaries (placeholder)
    generate_summaries(room_assignments, kill_info)

    return room_assignments, kill_info

# Helper function for choosing a room
def choose_room(character):
    available_rooms = [room for room in rooms if room not in crime_scenes]
    room = random.choice(available_rooms)
    print(f"{character} chooses to stay in the {room}.")
    return room

# Killer's decision-making process during the action stage
def killer_decision(room_assignments):
    for room, occupants in room_assignments.items():
        if killer in occupants:
            if len(occupants) > 1:
                return prompt_killer(room, occupants)
            elif len(occupants) == 2:
                victim = [char for char in occupants if char != killer][0]
                characters[victim]["alive"] = False
                print(f"{killer} kills {victim} in the {room}.")
                crime_scenes.append(room)
                return {"room": room, "victim": victim}
            else:
                print(f"{killer} could not kill anyone in the {room}.")
    return None

# Prompt the killer to choose if they want to kill someone
def prompt_killer(room, occupants):
    if len(occupants) > 1:
        choices = [char for char in occupants if char != killer]
        print(f"{killer}, you are in the {room} with {', '.join(choices)}. Who do you want to kill?")
        victim = generate_killer_decision(killer, choices, memory, rules)  # Placeholder for killer choice
        if victim != "NO":
            characters[victim]["alive"] = False
            crime_scenes.append(room)
            print(f"{killer} kills {victim} in the {room}.")
            return {"room": room, "victim": victim}
    return None


def check_direct_address(most_recent_message, characters, player_name):
    """Check if a character is directly addressed by name in the player's message."""

    most_recent_message = most_recent_message.split(":")[1]
    if most_recent_message.strip().replace(",","").split(" ")[0] == player_name:
        return player_name
    for character in characters:
        #print(most_recent_message.strip().split(" ")[0])
        if characters[character]["alive"] and (f". {character}" in most_recent_message or (most_recent_message.strip().replace(",", "").replace("'"," ").split(" ")[0] == character or most_recent_message.strip().split(",")[0] == character)):
            return character  # Return the character that is directly addressed
    return None

# # Conversation Phase
def conversation_stage(player_name):
    print("\nConversation Phase begins. Detective asks the first question.")

    short_term_memory = 2
    yap_counter = 0

    current_conversation = []
    most_recent_messageS = []

    alive_characters = [char for char in characters if characters[char]["alive"]]


    if random.randint(0,10) <= 7:
        first_to_answer = player_name
    else:
        first_to_answer = random.choice(alive_characters)

    most_recent_message = f"Detective: {first_to_answer}, let's start with you. Where were you last night? \n"
    print(most_recent_message)
    most_recent_messageS.append(most_recent_message)
    current_conversation.append(most_recent_message)

    if first_to_answer == player_name:
        print(f"Possible Locations: {rooms}")
        player_response = handle_player_interjection()
        most_recent_message = f"{player_name}: {player_response}"
        most_recent_messageS.append(most_recent_message)
        current_conversation.append(most_recent_message)
    
    for character in characters:
        characters[character]["memory"].append(f"\n Begin Day 1 (Conversation Phase 1): Alive suspects = [Jerry, Dave, Owen, Hank, {player_name}], Dead suspects = [Debra]. Rooms that were able to be occupied last night = [Attic, Kitchen, Library, Basement, Cellar], it is impossible for anyone to have occupied a location other than one of these rooms. \n" )
        characters[character]["memory"].append(f"The Detective reveals that Debra was killed last night, her body was found in the Kitchen, someone who stayed the night in the Kitchen must have killed her.")
        #characters[character]["memory"].append(f"The Detective: {player_response}")

    
    while True:

        if len(current_conversation) == 20: 
            print("CONVERSATION LENGTH REQUIREMENT MET: TYPE 'vote' AT ANY TIME TO INITIATE VOTING")

        mentioned = check_direct_address(most_recent_message, characters, player_name)
        #print("Mentioned: ", mentioned)
        if mentioned != None and mentioned != most_recent_message.split(":")[0]:
            if mentioned != player_name:
                if yap_counter >= 3 and player_interject():
                    player_response = handle_player_interjection()
                    if (player_response.strip().lower() == "vote" and len(current_conversation) >= 20):
                        votes = ai_vote_for_killer(player_name, characters, conversation_summary, rules)
                        break

                    most_recent_message = f"{player_name}: {player_response}"
                    yap_counter = 0
                else:
                    conversation_summary = summarise_conversation(current_conversation)
                    response = generate_conversation_speech(mentioned, characters, rules, conversation_summary, most_recent_message).replace("{", "").replace("}", "")
                    most_recent_message = f"{mentioned}: {response}"
                    yap_counter += 1
                    print(most_recent_message, "\n")

                most_recent_messageS.append(most_recent_message)
                if len(most_recent_messageS) > short_term_memory :
                    most_recent_messageS.pop(0)
                current_conversation.append(most_recent_message)
            else:
                player_response = handle_player_interjection()

                if (player_response.strip().lower() == "vote" and len(current_conversation) >= 20):
                    votes = ai_vote_for_killer(player_name, characters, conversation_summary, rules)
                    break
                most_recent_message = f"{player_name}: {player_response}"

                most_recent_messageS.append(most_recent_message)
                if len(most_recent_messageS) > short_term_memory :
                    most_recent_messageS.pop(0)
                current_conversation.append(most_recent_message)

                yap_counter = 0

        
        else:
            if most_recent_message.split(":")[0] != player_name and player_interject():

                player_response = handle_player_interjection()
                if (player_response.strip().lower() == "vote" and len(current_conversation) >= 20):
                    votes = ai_vote_for_killer(player_name, characters, conversation_summary, rules)
                    break
                most_recent_message = f"{player_name}: {player_response}"

                most_recent_messageS.append(most_recent_message)
                if len(most_recent_messageS) > short_term_memory :
                    most_recent_messageS.pop(0)
                current_conversation.append(most_recent_message)

                yap_counter = 0
                
            else:
                #print("No direct address detected and player passes")
                conversation_summary = summarise_conversation(current_conversation)
                #print(conversation_summary)
                responses = generate_responses(characters, rules,  conversation_summary, most_recent_messageS)
                best_response, speaker = select_best_response(responses, conversation_summary, most_recent_messageS)
                most_recent_message = f"{speaker}: {best_response}"

                print(most_recent_message, "\n")
                most_recent_messageS.append(most_recent_message)
                if len(most_recent_messageS) > short_term_memory :
                    most_recent_messageS.pop(0)
                current_conversation.append(most_recent_message)


        
        if len(current_conversation) >= 40:
            votes = ai_vote_for_killer(player_name, characters, conversation_summary, rules)
            break




# Handle player interjection
def handle_player_interjection():
    player_input = input("What would you like to say?")
    #print(f"You: {player_input} \n")
    return player_input

# Check if the player wants to interject
def player_interject():
    choice = input("Do you want to interject? (y/n): ").strip().lower()
    return choice == "y"

# Main game loop
def start_game():
    player_name = input("You there, what is your name?")
    print("The game begins with an action stage.")
    
    while True:
        # Action Stage
        #outputs = action_stage(inputs)
        
        # Check for game-ending conditions (if all but the detective and killer are dead)
        alive_count = sum(1 for char in characters if characters[char]["alive"])
        if alive_count <= 2:
            print("Only the detective and killer are left. Time to make a prediction!")
            break

        # Conversation Stage
        conversation_stage(player_name)

        # Check if the player wants to make a prediction
        if player_make_prediction():
            break

# Placeholder for player making a prediction
def player_make_prediction():
    prediction = input("Who do you think the killer is? (Enter name or 'continue'): ").strip()
    if prediction == killer:
        print(f"You win! The killer was {killer}.")
        # Calculate score based on how many participants are left alive
        alive_count = sum(1 for char in characters if characters[char]["alive"])
        print(f"Score: {alive_count} participants left alive.")
        return True
    elif prediction.lower() == "continue":
        return False
    else:
        print(f"Wrong guess! The killer was {killer}. You lose.")
        return True

if __name__ == "__main__":
    start_game()